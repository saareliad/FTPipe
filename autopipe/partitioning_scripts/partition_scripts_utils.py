import os
import pathlib
import shlex
import sys
from shutil import copyfile, rmtree
from string import Template
from typing import Tuple, Dict

import torch


def choose_blocks(model, args) -> Tuple[torch.nn.Module]:
    blocks = dict()

    for m in model.modules():
        m_superclasses = {c.__name__: c for c in type(m).mro()}
        blocks.update(m_superclasses)

    blocks: Dict[str, torch.nn.Module]
    if args.basic_blocks is None:
        args.basic_blocks = []
    try:
        return tuple([blocks[name] for name in args.basic_blocks])
    except KeyError:
        raise ValueError(f"invalid basic blocks possible blocks are {list(blocks.keys())}")


def record_cmdline(output_file):
    """Add cmdline to generated python output file."""
    cmdline = " ".join(map(shlex.quote, sys.argv[1:]))
    python_output_file = output_file + ".py"
    cmdline = '"""' + "AutoGenerated with:\n" + "python -m autopipe.partition " + cmdline + "\n" + '"""'
    if sys.platform == 'win32':
        cmdline = 'r'+cmdline
    with open(python_output_file, 'r+') as f:
        content = f.read()
        f.seek(0, 0)
        f.write(cmdline.rstrip('\r\n') + '\n' + content)

def record_transformer_cfg(python_output_file, args, model_type, explicitly_set_dict=dict(), do_resize_token_embedding=False):

    t = Template("""\n
def ${function_name}():
    return dict(model_type='${model_type}',
                model_name_or_path='${model_name_or_path}',
                do_lower_case=${do_lower_case},
                output_past=False,
                stateless_tied=${stateless_tied},
                explicitly_set_dict=${explicitly_set_dict},
                do_resize_token_embedding=${do_resize_token_embedding},
                )
    """)
    stateless_tied = getattr(args,"stateless_tied", False)
    do_lower_case = getattr(args, "do_lower_case", False)
    basename = os.path.basename(python_output_file)
    if basename.endswith(".py"):
        basename = basename[:-3]
    mapping = dict(function_name=basename,
                   model_type=model_type,
                   model_name_or_path=args.model_name_or_path,
                   do_lower_case=do_lower_case,
                   stateless_tied=stateless_tied,
                   explicitly_set_dict=explicitly_set_dict,
                   do_resize_token_embedding=do_resize_token_embedding
                   )
    s = t.substitute(mapping)

    with open(python_output_file, 'a') as f:
        # content = f.read()
        # f.seek(0, 0)
        f.write(s)




def bruteforce_main(main, main_kwargs=None, override_dicts=None, NUM_RUNS=2, TMP="/tmp/partitioning_outputs/", remove_tmp=False):
    # TODO: put all hyper parameters here, a dict for each setting we want to try.
    # d1 = dict(basic_blocks=[])
    # ovverride_dicts.append(d1)
    if main_kwargs is None:
        main_kwargs = dict()

    results = {}
    best = None

    if override_dicts is None:
        override_dicts = []

    if not override_dicts:
        override_dicts = [{}]

    os.makedirs(TMP, exist_ok=True)
    DICT_PREFIX = "_d%d"
    current_dict_prefix = ""
    last_exception = None
    for i, override_dict in enumerate(override_dicts):
        if i > 0:
            current_dict_prefix = DICT_PREFIX.format(i)
        for counter in range(NUM_RUNS):
            main_kwargs['override_dict'] = override_dict
            if NUM_RUNS>1:
                try:
                    out = main(**main_kwargs)
                except (Exception, RuntimeError, AssertionError) as e:
                    last_exception = e
                    continue
            else:
                out = main(**main_kwargs)

            (analysis_result, output_file) = out

            name = output_file
            orig_name = name
            flag = False

            if name in results:
                if name.endswith(".py"):
                    name = name[:-3]
                flag = True

            while (name + ".py" in results) or flag:
                flag = False
                name += f"_{counter}"

            name += current_dict_prefix

            new_path = pathlib.Path(TMP, os.path.basename(name) + ".py")
            copyfile(orig_name + ".py", new_path)  # Save the last generated file

            results[name] = analysis_result

            if best is None:
                best = (new_path, analysis_result)
            elif analysis_result > best[1]:
                best = (new_path, analysis_result)

    print(f"best: {best}")
    if best is None:
        print("-I- hyper parameter search failed raising last exception")
        raise last_exception
    copyfile(best[0], orig_name + ".py")
    print(f"-I- copied best to {orig_name}.py")
    if remove_tmp:
        rmtree(TMP)
